#!/usr/bin/python3
import argparse
import hashlib
import os
import shutil
import subprocess
import sys
import tempfile


def compare_files(source, target):
    if os.path.islink(source) or os.path.islink(target):
        return os.readlink(source) == os.readlink(target)

    if not os.path.isfile(source) or not os.path.isfile(target):
        return False

    hash_source = None
    hash_target = None

    try:
        with open(source, "rb") as fd_source:
            hash_source = hashlib.sha1(fd_source.read()).hexdigest()
    except:
        sys.stderr.write("Unable to hash: %s\n" % source)

    try:
        with open(target, "rb") as fd_target:
            hash_target = hashlib.sha1(fd_target.read()).hexdigest()
    except:
        sys.stderr.write("Unable to hash: %s\n" % target)

    return hash_source == hash_target


def checksum_content(path):
    set_content = set()
    dict_content = {}

    for dirName, subdirList, fileList in os.walk(path):
        dpath = dirName.replace(path, "")

        set_content.add((dpath, 'dir', None))
        dict_content[dpath] = ('dir', None)
        for fname in fileList:
            fpath = "%s/%s" % (dpath, fname)
            fhash = None

            if os.path.exists("%s/%s" % (dirName, fname)):
                fstat = os.stat("%s/%s" % (dirName, fname))
                fhash = ("%s" % fstat.st_mode,
                         "%s" % fstat.st_uid,
                         "%s" % fstat.st_gid,
                         "%s" % fstat.st_size,
                         "%s" % fstat.st_ctime,
                         "%s" % fstat.st_mtime)

            set_content.add((fpath, 'file', fhash))
            dict_content[fpath] = ('file', fhash)

    return (set_content, dict_content)


def mount_squashfs(squashfs, path):
    if subprocess.call(['mount', '-o', 'loop,ro', squashfs, path]) != 0:
        raise Exception("Failed to mount squashfs '%s' on '%s'" %
                        (squashfs, path))


def umount(path):
    if subprocess.call(['umount', path]) != 0:
        raise Exception("Failed to umount '%s'" % path)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="squashfs diff generator")

    parser.add_argument("source", metavar="SOURCE-SQUASHFS")
    parser.add_argument("target", metavar="TARGET-SQUASHFS")
    parser.add_argument("output", metavar="OUTPUT-PREFIX", nargs="?",
                        help="Output a squashfs with the diff along with "
                             "a file listing all removals.")

    args = parser.parse_args()

    # Some checks
    if not os.path.exists(args.source):
        parser.error("Source squashfs '%s' doesn't exist." % args.source)

    if not os.path.exists(args.target):
        parser.error("Target squashfs '%s' doesn't exist." % args.target)

    # Mount the two squashfs
    source = tempfile.mkdtemp()
    target = tempfile.mkdtemp()
    mount_squashfs(args.source, source)
    mount_squashfs(args.target, target)

    (set_source, dict_source) = checksum_content(source)
    (set_target, dict_target) = checksum_content(target)

    # Find the changes in the two trees
    changes = set()
    for change in set_source.symmetric_difference(set_target):
        if change[0] not in dict_source:
            changetype = "add"
        elif change[0] not in dict_target:
            changetype = "del"
        else:
            changetype = "mod"
        changes.add((change[0], changetype))

    # Do something with the changes
    if not hasattr(args, "output") or not args.output:
        # Print a list of the changes
        for change in sorted(changes):
            # Ignore files that only vary in ctime/mtime
            if change[1] == "mod":
                fstat_source = dict_source[change[0]][1]
                fstat_target = dict_target[change[0]][1]
                if (fstat_source[0:4] == fstat_target[0:4] and
                        compare_files("%s/%s" % (source, change[0]),
                                      "%s/%s" % (target, change[0]))):
                    continue

            print(" - %s (%s)" % (change[0], change[1]))
    else:
        # Generate the list of removals
        with open("%s.removals" % args.output, "w+") as fd:
            for change in sorted(changes):
                if change[1] != "del":
                    continue

                fd.write("%s\n" % change[0])

        output = tempfile.mkdtemp()

        # Copy all the added and modified
        for change in sorted(changes):
            if change[1] == "del":
                continue

            # Ignore files that only vary in ctime/mtime
            if change[1] == "mod":
                fstat_source = dict_source[change[0]][1]
                fstat_target = dict_target[change[0]][1]
                if (fstat_source[0:4] == fstat_target[0:4] and
                        compare_files("%s/%s" % (source, change[0]),
                                      "%s/%s" % (target, change[0]))):
                    continue

            ftarget = "%s/%s" % (target, change[0])
            fdestination = "%s/%s" % (output, change[0])

            fparent = "/".join(change[0].split("/")[0:-1])
            if not os.path.exists("%s/%s" % (output, fparent)):
                os.makedirs("%s/%s" % (output, fparent))

            if subprocess.call(["cp", "-aR", ftarget, fdestination]) != 0:
                sys.stderr.write("Failed to copy: %s\n" % ftarget)

        # Generate a squashfs
        if subprocess.call(["mksquashfs", output, "%s.squashfs" % args.output,
                            "-comp", "xz"]) != 0:
            sys.stderr.write("Failed to generate the squashfs: %s\n" %
                             "%s.squashfs" % args.output)

        shutil.rmtree(output)

    # Cleanup
    umount(source)
    umount(target)
    os.rmdir(source)
    os.rmdir(target)
