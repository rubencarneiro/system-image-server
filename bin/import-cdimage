#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (C) 2013 Canonical Ltd.
# Author: St√©phane Graber <stgraber@ubuntu.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
sys.path.insert(0, os.path.join(sys.path[0], os.pardir, "lib"))

from systemimage import config, gpg, tools, tree

import argparse
import glob
import shutil
import subprocess
import time

CURRENT_SERIES = "saucy"

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="import all new files from cdimage")

    parser.add_argument("cdimage_path", metavar="IMAGE-PATH")
    parser.add_argument("channel", metavar="CHANNEL")
    parser.add_argument('-n', '--dry-run', help="Don't actually "
                                                "convert/publish any file",
                        action="store_true", default=False)
    parser.add_argument('-q', '--quiet', help="Hide all info messages",
                        action="store_true", default=False)
    parser.add_argument('-p', '--proposed-channel', metavar="CHANNEL",
                        help="Channel to use for the untested images",
                        type=str, default=None)

    args = parser.parse_args()

    conf = config.Config()
    pub = tree.Tree(conf)

    mode = "stable"
    if args.proposed_channel:
        if args.proposed_channel != args.channel:
            mode = "split"
        else:
            mode = "merged"

    # Some checks
    if not os.path.exists(args.cdimage_path):
        parser.error("Invalid path: %s" % args.cdimage_path)

    if args.channel not in pub.list_channels():
        parser.error("Invalid channel: %s" % args.channel)

    if (mode == "split"
            and args.proposed_channel not in pub.list_channels()):
        parser.error("Invalid channel: %s" % args.proposed_channel)

    # Load the list of known files
    known_sums = []
    import_state = os.path.join(conf.base_path, "state",
                                "import-%s" % args.channel)
    if os.path.exists(import_state):
        with open(import_state, "r") as fd:
            known_sums = [line.strip() for line in fd]

    # Build a dict of device_name => Device object
    devices = {}
    for device_name in pub.list_channels()[args.channel]:
        devices[device_name] = pub.get_device(args.channel, device_name)

    proposed_devices = {}
    if mode == "split":
        for device_name in pub.list_channels()[args.proposed_channel]:
            proposed_devices[device_name] = pub.get_device(
                args.proposed_channel, device_name)

    # Build a dict of new files to process for each device
    to_process = {device_name: set() for device_name in devices}
    to_process['ubuntu'] = set()
    to_publish = {device_name: set() for device_name in devices}

    ignored_versions = ("current", "pending")
    if mode == "split":
        ignored_versions = ("current",)

    versions = [path.split("/")[-2]
                for path in glob.glob("%s/*/SHA256SUMS" % args.cdimage_path)
                if not [True for ignore in ignored_versions if ignore in path]]

    for version in sorted(versions):
        whitelist = []
        if os.path.exists("%s/%s/.marked_good" % (args.cdimage_path,
                                                  version)):
            with open("%s/%s/.marked_good" % (args.cdimage_path,
                                              version), "r") as fd:
                whitelist = fd.read().strip().split("\n")

        with open("%s/%s/SHA256SUMS" % (args.cdimage_path,
                                        version), "r") as fd:
            for line in fd:
                fields = line.split()
                file_sum = fields[0]
                file_name = fields[1].strip("*")

                # Skip untested files unless we ignore the flag
                if (mode != "merged" and file_name not in whitelist
                        and version != "pending"):
                    continue

                # Ignore files that were already imported
                if file_sum in known_sums:
                    continue

                if "boot-armhf" in file_name or "system-armel" in file_name:
                    device = file_name.split("+")[-1].split(".")[0]
                    # Ignore invalid devices
                    if not device in to_process:
                        continue

                    to_process[device].add(version)
                elif "touch-armhf.tar.gz" in file_name:
                    to_process['ubuntu'].add(version)
                else:
                    continue

                # We need to re-import proposed every time
                if version != "pending":
                    known_sums.append(file_sum)

    # Reset the proposed channel
    if mode == "split":
        if not args.dry_run:
            for device_name, device in proposed_devices.items():
                stable_device = devices[device_name]
                if os.path.exists(stable_device.indexpath):
                    shutil.copy(stable_device.indexpath, device.indexpath)
                    if os.path.exists("%s.asc" % device.indexpath):
                        os.remove("%s.asc" % device.indexpath)
                    gpg.sign_file(conf, "image-signing", device.indexpath)

    # Promote images from proposed to stable
    if mode == "split":
        for device, versions in to_process.items():
            stable_path = os.path.join(conf.publish_path, args.channel, device)
            proposed_path = os.path.join(conf.publish_path,
                                         args.proposed_channel, device)

            for version in versions:
                if version == "pending":
                    continue

                for entry in glob.glob("%s/%s-%s.*.tar.xz*" %
                                       (proposed_path, device, version)):
                    if not args.quiet:
                        print("Promoting '%s' to stable." % entry)
                    if not args.dry_run:
                        shutil.move(entry, stable_path)

    # Import the rootfs images
    for version in sorted(to_process['ubuntu']):
        path = os.path.realpath(os.path.join(args.cdimage_path, version,
                                "%s-preinstalled-touch-armhf.tar.gz" %
                                (CURRENT_SERIES)))

        real_version = path.split("/")[-2]

        if version == "pending":
            path_out = os.path.join(conf.publish_path, args.proposed_channel,
                                    "ubuntu",
                                    "ubuntu-%s.full.tar.xz" % real_version)
        else:
            path_out = os.path.join(conf.publish_path, args.channel, "ubuntu",
                                    "ubuntu-%s.full.tar.xz" % real_version)

        if not os.path.exists(path_out):
            if not args.quiet:
                print("Repacking '%s' as '%s'." % (path, path_out))

            if not args.dry_run:
                subprocess.call(["bin/repack-rootfs", path, path_out])
                gpg.sign_file(conf, "image-signing", path_out)

        for device in to_publish:
            if version == "pending":
                to_publish[device].add((real_version, "proposed"))
            else:
                to_publish[device].add((real_version, "stable"))

    # Import the system images
    for device in devices:
        for version in sorted(to_process[device]):
            system_path = os.path.realpath(os.path.join(args.cdimage_path,
                                           version,
                                           "%s-preinstalled-system-armel+"
                                           "%s.img" %
                                           (CURRENT_SERIES, device)))
            boot_path = os.path.realpath(os.path.join(args.cdimage_path,
                                         version,
                                         "%s-preinstalled-boot-armhf+"
                                         "%s.img" % (CURRENT_SERIES, device)))
            recovery_path = os.path.realpath(os.path.join(args.cdimage_path,
                                             version,
                                             "%s-preinstalled-recovery"
                                             "-armel+%s.img" %
                                             (CURRENT_SERIES, device)))

            real_version = system_path.split("/")[-2]

            if version == "pending":
                path_out = os.path.join(conf.publish_path,
                                        args.proposed_channel,
                                        device, "%s-%s.full.tar.xz" % (device,
                                        real_version))
            else:
                path_out = os.path.join(conf.publish_path, args.channel,
                                        device, "%s-%s.full.tar.xz" % (device,
                                        real_version))

            if not os.path.exists(path_out):
                if not args.quiet:
                    print("Packing '%s' and '%s' as '%s'." %
                          (system_path, boot_path, path_out))

                if not args.dry_run:
                    subprocess.call(["bin/pack-device", system_path, boot_path,
                                     recovery_path, path_out])
                    gpg.sign_file(conf, "image-signing", path_out)

            if version == "pending":
                to_publish[device].add((real_version, "proposed"))
            else:
                to_publish[device].add((real_version, "stable"))

    # Generate delta images
    for entry in list(devices.keys()) + ['ubuntu']:
        base_path = os.path.join(conf.publish_path, args.channel, entry)

        tarballs = {tarball.split(".full")[0].split("-")[-1]: tarball
                    for tarball in glob.glob("%s/*.full.tar.xz" % base_path)}

        # Append the pending image when using split channels
        if mode == "split":
            proposed_base_path = os.path.join(conf.publish_path,
                                              args.proposed_channel, entry)
            entries = glob.glob("%s/*.full.tar.xz" % proposed_base_path)
            if entries:
                tarball = sorted(entries)[-1]
                tarball_version = tarball.split(".full")[0].split("-")[-1]

                if tarball_version not in tarballs:
                    tarballs[tarball_version] = tarball

        versions = sorted(tarballs.keys())

        for i in range(len(tarballs)):

            if i == 0:
                continue

            path_src = tarballs[versions[i-1]]
            path_dst = tarballs[versions[i]]
            path_out = path_dst.replace(".full.tar.xz",
                                        ".delta-%s.tar.xz" % versions[i-1])

            if not os.path.exists(path_out):
                if not args.quiet:
                    print("Generating diff from '%s' to '%s'." % (path_src,
                                                                  path_dst))

                if not args.dry_run:
                    subprocess.call(["bin/generate-diff", path_src,
                                     path_dst, path_out])
                    gpg.sign_file(conf, "image-signing", path_out)

    # Publish
    for device_name, versions in sorted(to_publish.items()):
        for version, target_channel in sorted(versions):
            if not args.quiet:
                print("Processing updates for: %s => %s" %
                      (device_name, version))

            current_channel = args.channel
            if target_channel == "proposed":
                current_channel = args.proposed_channel

            # Grab last full and delta
            images = devices[device_name].list_images()
            full_images = sorted([image for image in images
                                  if image['type'] == "full"],
                                 key=lambda image: image['version'])
            delta_images = sorted([image for image in images
                                   if image['type'] == "delta"],
                                  key=lambda image: image['version'])
            last_full = None
            last_delta = None
            if full_images:
                last_full = full_images[-1]
            if delta_images:
                last_delta = delta_images[-1]

            # Publish a full image
            dep = os.path.join(conf.publish_path, current_channel, device_name,
                               "%s-%s.full.tar.xz" % (device_name, version))
            if not os.path.exists(dep):
                dep = "%s%s" % (conf.publish_path,
                                last_full['files'][1]['path'])

            indep = os.path.join(conf.publish_path, current_channel, "ubuntu",
                                 "ubuntu-%s.full.tar.xz" % version)
            if not os.path.exists(indep):
                indep = "%s%s" % (conf.publish_path,
                                  last_full['files'][0]['path'])

            last_version = 0
            if last_full and last_full['version'] > last_version:
                last_version = last_full['version']
            if last_delta and last_delta['version'] > last_version:
                last_version = last_delta['version']

            new_version = int(time.strftime("%Y%m00", time.gmtime()))
            if last_version >= new_version:
                new_version = last_version + 1

            version_path = os.path.join(conf.publish_path,
                                        current_channel, device_name,
                                        "version-%s.tar.xz" % new_version)

            if not args.quiet:
                print("Publishing full image '%s' (%s) to %s" % (new_version,
                                                                 version,
                                                                 device_name))

            if not args.dry_run:
                if not os.path.exists(version_path):
                    tools.generate_version_tarball(
                        conf, current_channel, str(new_version),
                        version_path.replace(".xz", ""))

                    tools.xz_compress(version_path.replace(".xz", ""))
                    os.remove(version_path.replace(".xz", ""))
                    gpg.sign_file(conf, "image-signing", version_path)

                if mode == "split":
                    if target_channel == "proposed":
                        proposed_devices[device_name].create_image(
                            "full", new_version, str(version), [indep, dep,
                                                                version_path])
                    else:
                        devices[device_name].create_image(
                            "full", new_version, str(version), [indep, dep,
                                                                version_path])
                        proposed_devices[device_name].create_image(
                            "full", new_version, str(version), [indep, dep,
                                                                version_path])
                else:
                    devices[device_name].create_image(
                        "full", new_version, str(version), [indep, dep,
                                                            version_path])

            # Publish delta images
            delta_versions = {}

            ## Look for hardware dependent deltas
            dep = glob.glob("%s/%s-%s.delta-*.tar.xz" %
                            (os.path.join(conf.publish_path, current_channel,
                                          device_name), device_name, version))
            for entry in dep:
                delta_version = entry.split(".tar.xz")[0].split("-")[-1]
                filename = "%s-%s.full.tar.xz" % (device_name, delta_version)
                base_version = [image['version'] for image in images
                                if [fileentry for fileentry in image['files']
                                    if fileentry['path'].endswith(filename)]]
                if not base_version:
                    continue

                base_version = sorted(base_version)[-1]

                if base_version not in delta_versions:
                    delta_versions[base_version] = {}

                delta_versions[base_version]['dep'] = entry

            ## Look for hardware independent deltas
            indep = glob.glob("%s/ubuntu/ubuntu-%s.delta-*.tar.xz" %
                              (os.path.join(conf.publish_path,
                                            current_channel),
                               version))
            for entry in indep:
                delta_version = entry.split(".tar.xz")[0].split("-")[-1]
                filename = "ubuntu-%s.full.tar.xz" % delta_version
                base_version = [image['version'] for image in images
                                if [fileentry for fileentry in image['files']
                                    if fileentry['path'].endswith(filename)]]
                if not base_version:
                    continue

                base_version = base_version[0]

                if base_version not in delta_versions:
                    delta_versions[base_version] = {}

                delta_versions[base_version]['indep'] = entry

            ## Generate the new image entries
            for base_version, file_list in sorted(delta_versions.items()):
                files = []

                if 'indep' in file_list:
                    files.append(file_list['indep'])

                if 'dep' in file_list:
                    files.append(file_list['dep'])

                files.append(version_path)

                if not args.quiet:
                    print("Publishing delta image from '%s' to '%s' (%s) to %s"
                          % (base_version, new_version, version,
                             device_name))
                if not args.dry_run:
                    if mode == "split":
                        if target_channel == "proposed":
                            proposed_devices[device_name].create_image(
                                "delta", new_version, str(version),
                                files, base=base_version)
                        else:
                            devices[device_name].create_image(
                                "delta", new_version, str(version),
                                files, base=base_version)
                            proposed_devices[device_name].create_image(
                                "delta", new_version, str(version),
                                files, base=base_version)
                    else:
                        devices[device_name].create_image(
                            "delta", new_version, str(version),
                            files, base=base_version)

    if not args.quiet:
        print("Saving new known hashes")

    if not args.dry_run:
        with open(import_state, "w+") as fd:
            fd.write("\n".join(known_sums))

        tools.sync_mirrors(conf)
