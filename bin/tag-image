#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (C) 2015 Canonical Ltd.
# Author: ≈Åukasz 'sil2100' Zemczak <lukasz.zemczak@ubuntu.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import json
import os
import sys
sys.path.insert(0, os.path.join(sys.path[0], os.pardir, "lib"))

from systemimage import config, generators, tools, tree

import argparse
import fcntl
import logging

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="image tagger")
    parser.add_argument("channel", metavar="CHANNEL")
    parser.add_argument("device", metavar="DEVICE")
    parser.add_argument("version", metavar="VERSION", type=int)
    parser.add_argument("tag", metavar="TAG")
    parser.add_argument("--verbose", "-v", action="count", default=0)

    args = parser.parse_args()

    # Setup logging
    formatter = logging.Formatter(
        "%(asctime)s %(levelname)s %(message)s")

    levels = {1: logging.ERROR,
              2: logging.WARNING,
              3: logging.INFO,
              4: logging.DEBUG}

    if args.verbose > 0:
        stdoutlogger = logging.StreamHandler(sys.stdout)
        stdoutlogger.setFormatter(formatter)
        logging.root.setLevel(levels[min(4, args.verbose)])
        logging.root.addHandler(stdoutlogger)
    else:
        logging.root.addHandler(logging.NullHandler())

    # Load the configuration
    conf = config.Config()

    # Try to acquire a global lock
    lock_file = os.path.join(conf.state_path, "global.lock")
    lock_fd = open(lock_file, 'w')

    try:
        fcntl.lockf(lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        print("Something else holds the global lock. exiting.")
        sys.exit(0)

    # Load the tree
    pub = tree.Tree(conf)

    # Do some checks
    if args.channel not in pub.list_channels():
        parser.error("Invalid channel: %s" % args.channel)

    if args.device not in pub.list_channels()[args.channel]['devices']:
        parser.error("Invalid device for channel: %s" % args.device)

    if "alias" in pub.list_channels()[args.channel] and \
            pub.list_channels()[args.channel]['alias'] \
            != args.channel:
        parser.error("Channel is an alias.")

    if "redirect" in pub.list_channels()[args.channel]:
        parser.error("Channel is a redirect.")

    if not args.tag:
        parser.error("Image tag must be a non-empty string.")

    if "," in args.tag:
        parser.error("Image tag cannot include the character ','.")

    device = pub.get_device(args.channel, args.device)

    device_images = device.list_images()
    if not device_images:
        parser.error("No images in selected channel/device.")

    sorted_images = sorted(device_images, key=lambda x: x['version'])
    if args.version != sorted_images[-1]['version']:
        parser.error("You can only tag the latest image.")

    # Extract the build we want to copy
    images = [image for image in device_images
              if image['type'] == "full" and image['version'] == args.version]
    if not images:
        parser.error("Can't find version: %s" % args.version)
    image = images[0]

    # Assign a new version number
    new_version = args.version + 1

    # Create new empty entries
    new_images = {'full': {'files': []}}

    # Extract current version_detail and files
    version_detail = ""
    for entry in image['files']:
        path = os.path.realpath("%s/%s" % (conf.publish_path, entry['path']))

        filename = path.split("/")[-1]

        # Look for version-X.tar.xz
        if filename == "version-%s.tar.xz" % args.version:
            # Extract the metadata
            if os.path.exists(path.replace(".tar.xz", ".json")):
                with open(path.replace(".tar.xz", ".json"), "r") as fd:
                    metadata = json.loads(fd.read())
                    if "channel.ini" in metadata:
                        version_detail = metadata['channel.ini'].get(
                            "version_detail", None)
        else:
            new_images['full']['files'].append(path)
    logging.debug("Source version_detail is: %s" % version_detail)

    # Generate new version tarball
    environment = {}
    environment['channel_name'] = args.channel
    environment['device'] = device
    environment['device_name'] = args.device
    environment['version'] = new_version
    environment['version_detail'] = [entry
                                     for entry in version_detail.split(",")
                                     if not entry.startswith("version=")]
    environment['new_files'] = new_images['full']['files']

    # Remove existing tag
    for detail in environment['version_detail']:
        if detail.startswith("tag="):
            environment['version_detail'].remove(detail)

    # Append the new tag
    environment['version_detail'].append("tag=%s" % args.tag)
    logging.info("Setting tag for image to '%s'" % args.tag)

    logging.info("Generating new version tarball for '%s' (%s)"
                 % (new_version, ",".join(environment['version_detail'])))
    version_path = generators.generate_file(conf, "version", [], environment)
    if version_path:
        new_images['full']['files'].append(version_path)

    # Add full image
    logging.info("Publishing new image '%s' (%s) with %s files."
                 % (new_version, ",".join(environment['version_detail']),
                    len(new_images['full']['files'])))
    device.create_image(
        "full", new_version, ",".join(environment['version_detail']),
        new_images['full']['files'],
        version_detail=",".join(environment['version_detail']))

    # TODO: Phased percentage

    # Set the phased percentage value for the new image
    #logging.info("Setting phased percentage of the new image to %s%%" %
    #             args.phased_percentage)
    #destination_device.set_phased_percentage(
    #    new_version, args.phased_percentage)

    # Expire images
    if args.channel in conf.channels:
        if conf.channels[args.channel].fullcount > 0:
            logging.info("Expiring old images")
            device.expire_images(conf.channels[args.channel].fullcount)

    # Sync all channel aliases
    logging.info("Syncing any existing alias")
    pub.sync_aliases(args.channel)

    # Remove any orphaned file
    logging.info("Removing orphaned files from the pool")
    pub.cleanup_tree()

    # Sync the mirrors
    logging.info("Triggering a mirror sync")
    tools.sync_mirrors(conf)
